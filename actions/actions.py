from typing import Any, Text, Dict, List
import json, re
from rasa_sdk import Action, Tracker
from rasa_sdk.executor import CollectingDispatcher
import pandas as pd
import difflib

from rasa_sdk.events import SlotSet


class ActionProvideFoodInfo(Action):

    # Tr·∫£ v·ªÅ t√™n c·ªßa action, d√πng t√™n n√†y ƒë·ªÉ g·ªçi ƒë√∫ng action t∆∞∆°ng ·ª©ng khi d·ª± ƒëo√°n
    # Ni l√† type hint -> h√†m s·∫Ω tr·∫£ v·ªÅ 1 gi√° tr·ªã ki·ªÉu text
    def name(self) -> Text:
        return "action_provide_food_info"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        food_name = next(tracker.get_latest_entity_values("food_name"), None)
        if not food_name:
            dispatcher.utter_message(
                text="B·∫°n mu·ªën h·ªèi th√¥ng tin v·ªÅ m√≥n g√¨ v·∫≠y?")
            return []

        # Load data tu JSON
        with open("actions/data/specialty_foods.json", "r", encoding="utf-8") as f:
            foods = json.load(f)

        for food in foods:
            if food_name.lower().strip() in food["name"].lower():
                msg = f"üçΩ {food['name']}\n"
                msg += f"{food['description']}. ƒê·ªãa ch·ªâ n·∫±m ·ªü: {', '.join(food['addresses'])}. Gi√° trung b√¨nh ·ªü ƒë√† n·∫µng l√† {food['average_price']}k b·∫°n nh√©üí∞!"
                dispatcher.utter_message(text=msg)
                return []

        dispatcher.utter_message(
            text=f"Xin l·ªói, m√¨nh ch∆∞a c√≥ th√¥ng tin v·ªÅ m√≥n {food_name}. M√¨nh s·∫Ω g·∫Øng c·∫≠p nh·∫≠t th√¥ng tin ƒë·ªÉ gi·∫£i ƒë√°p th·∫Øc m·∫Øc cho b·∫°n nh√©!")
        return []

class ActionListManyFoods(Action):
    def name(self) -> Text:
        return "action_list_many_foods"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        shown_foods_indices = tracker.get_slot("shown_foods_indices")

        with open("actions/data/specialty_foods.json", "r", encoding="utf-8") as f:
            foods = json.load(f)

        if not shown_foods_indices:
            shown_foods_indices = []

        foods_per_page = 7

        if len(shown_foods_indices) >= len(foods):
            dispatcher.utter_message(
                text="M√¨nh ƒë√£ gi·ªõi thi·ªáu h·∫øt c√°c m√≥n ƒÉn ƒë·∫∑c s·∫£n c·ªßa ƒê√† N·∫µng r·ªìi. B·∫°n mu·ªën bi·∫øt th√™m th√¥ng tin g√¨ kh√°c kh√¥ng?")
            return [SlotSet("shown_foods_indices", [])]  # Reset l·∫°i slot

        remaining_indices = [i for i in range(
            len(foods)) if i not in shown_foods_indices]
        num_to_show = min(foods_per_page, len(remaining_indices))
        indices_to_show = remaining_indices[:num_to_show]

        # Update danh s√°ch c√°c m√≥n ƒë√£ hi·ªÉn th·ªã
        shown_foods_indices.extend(indices_to_show)

        response = "\n"
        for idx in indices_to_show:
            response += f"{foods[idx]['name']}; "
        response += "\nB·∫°n mu·ªën bi·∫øt th√™m th√¥ng tin chi ti·∫øt v·ªÅ m√≥n n√†o? H√£y nh·∫Øn t√™n m√≥n ƒÉn ƒë·ªÉ m√¨nh gi·ªõi thi·ªáu nh√©!"

        dispatcher.utter_message(text=response)

        # L∆∞u l·∫°i danh s√°ch c√°c m√≥n ƒë√£ hi·ªÉn th·ªã
        return [SlotSet("shown_foods_indices", shown_foods_indices)]

class ActionProvideFoodPrice(Action):
    def name(self) -> Text:
        return "action_provide_food_price"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        food_name = next(tracker.get_latest_entity_values("food_name"), None)
        if not food_name:
            dispatcher.utter_message(text="B·∫°n mu·ªën h·ªèi gi√° m√≥n g√¨ v·∫≠y?")
            return []

        with open("actions/data/specialty_foods.json", "r", encoding="utf-8") as f:
            foods = json.load(f)

        for food in foods:
            if food_name.lower().strip() in food["name"].lower():
                dispatcher.utter_message(
                    text=f"üí∞ M√≥n {food['name']} c√≥ gi√° trung b√¨nh kho·∫£ng {food['average_price']}k b·∫°n nh√©!")
                return []

        dispatcher.utter_message(
            text=f"Xin l·ªói, m√¨nh ch∆∞a c√≥ th√¥ng tin gi√° c·ªßa m√≥n {food_name}.")
        return []

class ActionProvideFoodLocation(Action):

    def name(self) -> Text:
        return "action_provide_food_location"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        food_name = next(tracker.get_latest_entity_values("food_name"), None)
        if not food_name:
            dispatcher.utter_message(
                text="B·∫°n mu·ªën t√¨m ƒë·ªãa ƒëi·ªÉm c·ªßa m√≥n n√†o v·∫≠y?")
            return []

        with open("actions/data/specialty_foods.json", "r", encoding="utf-8") as f:
            foods = json.load(f)

        for food in foods:
            if food_name.lower().strip() in food["name"].lower():
                dispatcher.utter_message(
                    text=f"üìçB·∫°n c√≥ th·ªÉ th∆∞·ªüng th·ª©c {food['name']} t·∫°i: {', '.join(food['addresses'])}.")
                return []

        dispatcher.utter_message(
            text=f"Xin l·ªói, m√¨nh ch∆∞a bi·∫øt ƒë·ªãa ƒëi·ªÉm b√°n m√≥n {food_name} r·ªìi :(")
        return []
    

# Coffee and Milk tea
class ActionListManyCoffee(Action):
    def name(self) -> Text:
        return "action_list_many_coffees"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        shown_coffees_indices = tracker.get_slot("shown_coffees_indices")

        with open("actions/data/danang_coffee_milktea_selenium.json", "r", encoding="utf-8") as f:
            coffees = json.load(f)

        if not shown_coffees_indices:
            shown_coffees_indices = []

        coffees_per_page = 7

        if len(shown_coffees_indices) >= len(coffees):
            dispatcher.utter_message(
                text="M√¨nh ƒë√£ gi·ªõi thi·ªáu h·∫øt c√°c qu√°n c√† ph√™/ tr√† s·ªØa n·ªïi ti·∫øng c·ªßa ƒê√† N·∫µng r·ªìi. B·∫°n mu·ªën bi·∫øt th√™m th√¥ng tin g√¨ kh√°c kh√¥ng?")
            return [SlotSet("shown_coffees_indices", [])]  # Reset l·∫°i slot

        remaining_indices = [i for i in range(
            len(coffees)) if i not in shown_coffees_indices]
        num_to_show = min(coffees_per_page, len(remaining_indices))
        indices_to_show = remaining_indices[:num_to_show]

        # Update danh s√°ch c√°c qu√°n ƒë√£ hi·ªÉn th·ªã
        shown_coffees_indices.extend(indices_to_show)

        response = "\n"
        response = "ƒê√¢y l√† c√°c qu√°n c√† ph√™ m√† b·∫°n n√™n th·ª≠ gh√© qua m·ªôt l·∫ßn nhaaaaa: \n"
        for idx in indices_to_show:
            response += f"{coffees[idx]['name']}; "

        dispatcher.utter_message(text=response)

        # L∆∞u l·∫°i danh s√°ch c√°c m√≥n ƒë√£ hi·ªÉn th·ªã
        return [SlotSet("shown_coffees_indices", shown_coffees_indices)]

class ActionProvideCoffeeInfo(Action):

    def name(self) -> Text:
        return "action_provide_coffee_info"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        coffee_name = next(tracker.get_latest_entity_values("coffee_name"), None)
        if not coffee_name:
            dispatcher.utter_message(
                text="B·∫°n mu·ªën h·ªèi th√¥ng tin v·ªÅ qu√°n c√† ph√™ n√†o v·∫≠y?")
            return []

        with open("actions/data/danang_coffee_milktea_selenium.json", "r", encoding="utf-8") as f:
            coffees = json.load(f)

        for coffee in coffees:
            if coffee_name.lower().strip() in coffee["name"].lower():
                msg = f"‚òï {coffee['name']} c√≥ ƒëi·ªÉm ƒë√°nh gi√° trung b√¨nh {coffee['rating']}/10."

                if coffee['address'] != "N/A" and coffee['district'] != "N/A":
                    msg += f" ƒê·ªãa ch·ªâ qu√°n l√† {coffee['address']}, {coffee['district']}."
                else:
                    msg += " ƒê√¢y l√† h·ªá th·ªëng qu√°n v√† kh√¥ng c√≥ ƒë·ªãa ch·ªâ c·ª• th·ªÉ."

                msg += f" B·∫°n c√≥ th·ªÉ xem th√™m chi ti·∫øt t·∫°i: {coffee['URL']}."
                dispatcher.utter_message(text=msg)
                return []

        dispatcher.utter_message(
            text=f"Xin l·ªói, m√¨nh ch∆∞a c√≥ th√¥ng tin v·ªÅ qu√°n {coffee_name}. M√¨nh s·∫Ω c·ªë g·∫Øng c·∫≠p nh·∫≠t th√™m nh√©!")
        return []

class ActionProvideCoffeeLocation(Action):

    def name(self) -> Text:
        return "action_provide_coffee_location"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        coffee_name = next(tracker.get_latest_entity_values("coffee_name"), None)
        if not coffee_name:
            dispatcher.utter_message(
                text="B·∫°n mu·ªën t√¨m ƒë·ªãa ƒëi·ªÉm c·ªßa qu√°n n√†o v·∫≠y?")
            return []

        with open("actions/data/danang_coffee_milktea_selenium.json", "r", encoding="utf-8") as f:
            coffees = json.load(f)

        found_coffee_info = False

        for coffee in coffees:
            if coffee_name.lower().strip() in coffee["name"].lower():
                found_coffee_info = True

                if coffee["address"] and coffee["address"].lower() != "n/a":
                    dispatcher.utter_message(
                        text=f"üìçB·∫°n c√≥ th·ªÉ gh√© {coffee['name']} t·∫°i: {coffee['address']}."
                    )
                else:
                    dispatcher.utter_message(
                        text=f"Xin l·ªói, m√¨nh ch∆∞a c√≥ th√¥ng tin ƒë·ªãa ƒëi·ªÉm c·ª• th·ªÉ cho qu√°n {coffee['name']} r·ªìi :("
                    )
                return [SlotSet("coffee_name", None)]

        if not found_coffee_info:
            dispatcher.utter_message(
                text=f"Xin l·ªói, m√¨nh ch∆∞a c√≥ th√¥ng tin v·ªÅ qu√°n {coffee_name}. B·∫°n c√≥ ch·∫Øc ƒë√≥ l√† t√™n qu√°n kh√¥ng?"
            )
        
        return [SlotSet("coffee_name", None)] # T√πy ch·ªçn: reset slot ngay c·∫£ khi kh√¥ng t√¨m th·∫•y

class ActionFilterCoffeeByRating(Action):

    def name(self) -> Text:
        return "action_filter_coffee_by_rating"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        # L·∫•y gi√° tr·ªã entity rating t·ª´ c√¢u h·ªèi
        rating_str = next(tracker.get_latest_entity_values("rating"), None)
        if rating_str is None:
            dispatcher.utter_message(text="B·∫°n mu·ªën t√¨m c√°c qu√°n c√≥ ƒëi·ªÉm rating l·ªõn h∆°n bao nhi√™u?")
            return []

        try:
            threshold = float(rating_str)
        except ValueError:
            dispatcher.utter_message(text="M√¨nh kh√¥ng hi·ªÉu ƒëi·ªÉm b·∫°n mu·ªën t√¨m l√† bao nhi√™u. B·∫°n th·ª≠ l·∫°i nh√©.")
            return []

        # ƒê·ªçc file d·ªØ li·ªáu JSON
        with open("actions/data/danang_coffee_milktea_selenium.json", "r", encoding="utf-8") as f:
            coffees = json.load(f)

        # L·ªçc qu√°n c√≥ rating l·ªõn h∆°n threshold
        filtered = [
            f"{coffee['name']} (Rating: {coffee['rating']})"
            for coffee in coffees
            if float(coffee.get("rating", 0)) > threshold
        ]

        # Tr·∫£ l·ªùi ng∆∞·ªùi d√πng
        if filtered:
            message = f"C√°c qu√°n c√≥ rating > {threshold}:\n- " + "\n- ".join(filtered)
        else:
            message = f"Kh√¥ng t√¨m th·∫•y qu√°n n√†o c√≥ ƒëi·ªÉm rating l·ªõn h∆°n {threshold}."

        dispatcher.utter_message(text=message)
        return []

# FAQ Food
class ActionAnswerFoodFAQ(Action):

    def name(self) -> Text:
        return "action_answer_food_faq" 
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        user_question = tracker.latest_message.get("text", "").lower()

        # Doc file excel
        df = pd.read_excel("actions/data/100_questions_answers_grabfood.xlsx")
        questions = df["Question"].astype(str).tolist()
        answers = df["Answer"].astype(str).tolist()

        # So khop voi cau hoi gan nhat
        closest = difflib.get_close_matches(user_question, questions, n=1, cutoff=0.5)
        if closest: 
            idx = questions.index(closest[0])
            dispatcher.utter_message(text=answers[idx])
        else:
            dispatcher.utter_message(text="Xin l·ªói, m√¨nh ch∆∞a r√µ c√¢u h·ªèi ƒë√≥. B·∫°n c√≥ th·ªÉ h·ªèi l·∫°i r√µ h∆°n ƒë∆∞·ª£c kh√¥ng?")

        return []
    

# Streetfood
class ActionListManyStreetFood(Action):
    def name(self) -> Text:
        return "action_list_many_streetfoods"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        shown_streetfoods_indices = tracker.get_slot("shown_streetfoods_indices")

        with open("actions/data/danang_streetfood_selenium.json", "r", encoding="utf-8") as f:
            streetfoods = json.load(f)

        if not shown_streetfoods_indices:
            shown_streetfoods_indices = []

        streetfoods_per_page = 7

        if len(shown_streetfoods_indices) >= len(streetfoods):
            dispatcher.utter_message(
                text="M√¨nh ƒë√£ gi·ªõi thi·ªáu h·∫øt c√°c qu√°n ƒÉn v·∫∑t n·ªïi ti·∫øng c·ªßa ƒê√† N·∫µng r·ªìi. B·∫°n mu·ªën bi·∫øt th√™m th√¥ng tin g√¨ kh√°c kh√¥ng?")
            return [SlotSet("shown_streetfoods_indices", [])]  # Reset l·∫°i slot

        remaining_indices = [i for i in range(
            len(streetfoods)) if i not in shown_streetfoods_indices]
        num_to_show = min(streetfoods_per_page, len(remaining_indices))
        indices_to_show = remaining_indices[:num_to_show]

        # Update danh s√°ch c√°c qu√°n ƒë√£ hi·ªÉn th·ªã
        shown_streetfoods_indices.extend(indices_to_show)

        response = "\n"
        response = "ƒê√¢y l√† c√°c qu√°n ƒÉn v·∫∑t m√† b·∫°n n√™n th·ª≠ gh√© qua m·ªôt l·∫ßn nhaaaaa: \n"
        for idx in indices_to_show:
            response += f"{streetfoods[idx]['name']}; "

        dispatcher.utter_message(text=response)

        # L∆∞u l·∫°i danh s√°ch c√°c m√≥n ƒë√£ hi·ªÉn th·ªã
        return [SlotSet("shown_streetfoods_indices", shown_streetfoods_indices)]
    
class ActionProvideStreetFoodInfo(Action):

    def name(self) -> Text:
        return "action_provide_streetfood_info"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        streetfood_name = next(tracker.get_latest_entity_values("streetfood_name"), None)
        if not streetfood_name:
            dispatcher.utter_message(
                text="B·∫°n mu·ªën h·ªèi th√¥ng tin v·ªÅ qu√°n ƒÉn v·∫∑t n√†o v·∫≠y?")
            return []

        with open("actions/data/danang_streetfood_selenium.json", "r", encoding="utf-8") as f:
            streetfoods = json.load(f)

        for streetfood in streetfoods:
            if streetfood_name.lower().strip() in streetfood["name"].lower():
                msg = f"üçó {streetfood['name']} c√≥ ƒëi·ªÉm ƒë√°nh gi√° trung b√¨nh {streetfood['street_rating']}/10."

                if streetfood['address'] != "N/A" and streetfood['district'] != "N/A":
                    msg += f" ƒê·ªãa ch·ªâ qu√°n l√† {streetfood['address']}, {streetfood['district']}."
                else:
                    msg += " ƒê√¢y l√† h·ªá th·ªëng qu√°n v√† kh√¥ng c√≥ ƒë·ªãa ch·ªâ c·ª• th·ªÉ."

                msg += f" B·∫°n c√≥ th·ªÉ xem th√™m chi ti·∫øt t·∫°i: {streetfood['URL']}."
                dispatcher.utter_message(text=msg)
                return []

        dispatcher.utter_message(
            text=f"Xin l·ªói, m√¨nh ch∆∞a c√≥ th√¥ng tin v·ªÅ qu√°n {streetfood_name}. M√¨nh s·∫Ω c·ªë g·∫Øng c·∫≠p nh·∫≠t th√™m nh√©!")
        return []
    
class ActionProvideStreetFoodLocation(Action):

    def name(self) -> Text:
        return "action_provide_streetfood_location"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        streetfood_name = next(tracker.get_latest_entity_values("streetfood_name"), None)
        if not streetfood_name:
            dispatcher.utter_message(
                text="B·∫°n mu·ªën t√¨m ƒë·ªãa ƒëi·ªÉm c·ªßa qu√°n n√†o v·∫≠y?")
            return []

        with open("actions/data/danang_streetfood_selenium.json", "r", encoding="utf-8") as f:
            streetfoods = json.load(f)

        found_streetfood_info = False

        for streetfood in streetfoods:
            if streetfood_name.lower().strip() in streetfood["name"].lower():
                found_streetfood_info = True

                if streetfood["address"] and streetfood["address"].lower() != "n/a":
                    dispatcher.utter_message(
                        text=f"üìçB·∫°n c√≥ th·ªÉ gh√© {streetfood['name']} t·∫°i: {streetfood['address']}."
                    )
                else:
                    dispatcher.utter_message(
                        text=f"Xin l·ªói, m√¨nh ch∆∞a c√≥ th√¥ng tin ƒë·ªãa ƒëi·ªÉm c·ª• th·ªÉ cho qu√°n {streetfood['name']} r·ªìi :("
                    )
                return [SlotSet("streetfood_name", None)]

        if not found_streetfood_info:
            dispatcher.utter_message(
                text=f"Xin l·ªói, m√¨nh ch∆∞a c√≥ th√¥ng tin v·ªÅ qu√°n {streetfood_name}. B·∫°n c√≥ ch·∫Øc ƒë√≥ l√† t√™n qu√°n kh√¥ng?"
            )
        
        return [SlotSet("streetfood_name", None)] # T√πy ch·ªçn: reset slot ngay c·∫£ khi kh√¥ng t√¨m th·∫•y
    
class ActionFilterStreetFoodByRating(Action):

    def name(self) -> Text:
        return "action_filter_streetfood_by_rating"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:

        # L·∫•y gi√° tr·ªã entity rating t·ª´ c√¢u h·ªèi
        rating_str = next(tracker.get_latest_entity_values("street_rating"), None)
        if rating_str is None:
            dispatcher.utter_message(text="B·∫°n mu·ªën t√¨m c√°c qu√°n c√≥ ƒëi·ªÉm rating l·ªõn h∆°n bao nhi√™u?")
            return []

        try:
            threshold = float(rating_str)
        except ValueError:
            dispatcher.utter_message(text="M√¨nh kh√¥ng hi·ªÉu ƒëi·ªÉm b·∫°n mu·ªën t√¨m l√† bao nhi√™u. B·∫°n th·ª≠ l·∫°i nh√©.")
            return []

        # ƒê·ªçc file d·ªØ li·ªáu JSON
        with open("actions/data/danang_streetfood_selenium.json", "r", encoding="utf-8") as f:
            streetfoods = json.load(f)

        # L·ªçc qu√°n c√≥ rating l·ªõn h∆°n threshold
        filtered = [
            f"{streetfood['name']} (Rating: {streetfood['street_rating']})"
            for streetfood in streetfoods
            if float(streetfood.get("street_rating", 0)) > threshold
        ]

        # Tr·∫£ l·ªùi ng∆∞·ªùi d√πng
        if filtered:
            message = f"C√°c qu√°n c√≥ rating > {threshold}:\n- " + "\n- ".join(filtered)
        else:
            message = f"Kh√¥ng t√¨m th·∫•y qu√°n n√†o c√≥ ƒëi·ªÉm rating l·ªõn h∆°n {threshold}."

        dispatcher.utter_message(text=message)
        return []